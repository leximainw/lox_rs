use super::{
    LoxValue,
    TokenType
};

struct AstPrinter{}
impl Visitor<String> for AstPrinter
{
	fn visit_binary(&self, expr: &Binary) -> String
	{
		let oper = match expr.oper
		{
			TokenType::Plus => "+",
			TokenType::Minus => "-",
			TokenType::Star => "*",
			TokenType::Slash => "/",
			_ => panic!()
		};
		format!("({oper} {} {})",
			expr.left.visit(self),
			expr.right.visit(self))
	}

	fn visit_grouping(&self, expr: &Grouping) -> String
	{
		format!("(group {})", expr.expr.visit(self))
	}

	fn visit_literal(&self, expr: &Literal) -> String
	{
		format!("{:?}", expr.value)
	}

	fn visit_unary(&self, expr: &Unary) -> String
	{
		let oper = match expr.oper
		{
			TokenType::Bang => "!",
			TokenType::Minus => "-",
			_ => panic!()
		};
		format!("({oper} {})", expr.expr.visit(self))
	}
}

// autogenerated code

trait Expr
{
	fn visit(&self, visitor: &AstPrinter) -> String;
}

trait Visitor<I>
{
	fn visit_binary(&self, expr: &Binary) -> I;
	fn visit_grouping(&self, expr: &Grouping) -> I;
	fn visit_literal(&self, expr: &Literal) -> I;
	fn visit_unary(&self, expr: &Unary) -> I;
}

struct Binary
{
	left: Box<dyn Expr>,
	oper: TokenType,
	right: Box<dyn Expr>
}

impl Binary
{
	pub fn visit<I>(&self, visitor: &dyn Visitor<I>) -> I
	{
		visitor.visit_binary(self)
	}
}

struct Grouping
{
	expr: Box<dyn Expr>
}

impl Grouping
{
	pub fn visit<I>(&self, visitor: &dyn Visitor<I>) -> I
	{
		visitor.visit_grouping(self)
	}
}

struct Literal
{
	value: LoxValue
}

impl Literal
{
	pub fn visit<I>(&self, visitor: &dyn Visitor<I>) -> I
	{
		visitor.visit_literal(self)
	}
}

struct Unary
{
	oper: TokenType,
	expr: Box<dyn Expr>
}

impl Unary
{
	pub fn visit<I>(&self, visitor: &dyn Visitor<I>) -> I
	{
		visitor.visit_unary(self)
	}
}
