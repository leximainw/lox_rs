pub mod executor;
pub mod printer;

use super::{
    LoxValue,
    TokenType
};

// impl Visitor<String> for AstPrinter: print;
use printer::AstPrinter;

// impl Visitor<Result<LoxValue, String>> for AstExecutor: run;
use executor::AstExecutor;

// autogenerated code

pub trait Expr
{
	fn print(&self, visitor: &AstPrinter) -> String;
	fn run(&self, visitor: &AstExecutor) -> Result<LoxValue, String>;
}

trait Visitor<I>
{
	fn visit_binary(&self, expr: &Binary) -> I;
	fn visit_grouping(&self, expr: &Grouping) -> I;
	fn visit_literal(&self, expr: &Literal) -> I;
	fn visit_unary(&self, expr: &Unary) -> I;
}

pub struct Binary
{
	pub left: Box<dyn Expr>,
	pub oper: TokenType,
	pub right: Box<dyn Expr>
}

impl Expr for Binary
{
	fn print(&self, visitor: &AstPrinter) -> String
	{ visitor.visit_binary(self) }
	fn run(&self, visitor: &AstExecutor) -> Result<LoxValue, String>
	{ visitor.visit_binary(self) }
}

pub struct Grouping
{
	pub expr: Box<dyn Expr>
}

impl Expr for Grouping
{
	fn print(&self, visitor: &AstPrinter) -> String
	{ visitor.visit_grouping(self) }
	fn run(&self, visitor: &AstExecutor) -> Result<LoxValue, String>
	{ visitor.visit_grouping(self) }
}

pub struct Literal
{
	pub value: LoxValue
}

impl Expr for Literal
{
	fn print(&self, visitor: &AstPrinter) -> String
	{ visitor.visit_literal(self) }
	fn run(&self, visitor: &AstExecutor) -> Result<LoxValue, String>
	{ visitor.visit_literal(self) }
}

pub struct Unary
{
	pub oper: TokenType,
	pub expr: Box<dyn Expr>
}

impl Expr for Unary
{
	fn print(&self, visitor: &AstPrinter) -> String
	{ visitor.visit_unary(self) }
	fn run(&self, visitor: &AstExecutor) -> Result<LoxValue, String>
	{ visitor.visit_unary(self) }
}
