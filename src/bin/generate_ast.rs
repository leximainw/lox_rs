use std::{
    env,
    fs,
    str
};

const TAB_SIZE: usize = 4;

fn main()
{
    env::args().skip(1).for_each(|arg| {
        match fs::read(&arg)
        {
            Ok(data) => match str::from_utf8(&data)
            {
                Ok(text) => match fs::write(&arg, generate_ast(text))
                {
                    Ok(()) => {},
                    Err(err) => println!("Error writing {arg}: {err}")
                },
                Err(err) => println!("Error reading {arg}: {err}")
            },
            Err(err) => println!("Error reading {arg}: {err}")
        }
    });
}

fn generate_ast(mut slice: &str) -> String
{
    const GEN_MARKER: &str = "\n// autogenerated code\n";
    const TYPE_CODE: &str = "\npub struct TYPE\n{\nARGSN\n}\n";
    const MAIN_TRAIT: &str = "\npub trait MAIN\n{\n\tMETHODS\n}\n";
    const MAIN_ATTR: &str = "\tpub NAME: TYPE;\n";
    const ATTR_DECL: &str = "\tfn NAME(&self) -> TYPE;\n";
    const CAST_DECL: &str = "\tfn to_TYPEL(self: Box<Self>) -> Option<TYPE>;\n";
    const REF_CAST_DECL: &str = "\tfn as_TYPEL(&self) -> Option<&TYPE>;\n";
    const MAIN_VISIT: &str = "\tfn VERB(&self, VERB: &mut TYPE) -> RETURNS;\n";
    const MAIN_VISIT_BODY: &str = "\n\t{ VERB.visit_TYPEL(self) }";
    const VISIT_TRAIT: &str = "\ntrait Visitor<I>\n{\nMETHODS}\n";
    const VISIT_METHOD: &str = "\tfn visit_TYPEL(&mut self, expr: &TYPE) -> I;\n";
    const VISIT_CODE: &str = "\nimpl MAIN for TYPE\n{\n\tMETHODS\n}\n";

    if let Some(index) = slice.find(GEN_MARKER)
    { slice = &slice[..index]; }
    let mut text: String = slice.to_string();
    let mut pos = 0;
    let mut visitors: Vec<(&str, &str, &str)> = Vec::new();
    let mut attrs: Vec<(&str, &str)> = Vec::new();
    let mut casts: Vec<&str> = Vec::new();
    let mut ref_casts: Vec<&str> = Vec::new();
    let mut type_fields: Vec<(&str, &str)> = Vec::new();

    let main_type = if let Some(index) = slice.find("// trait:")
    {
        if let Some(end) = slice[index..]
            .find(";").map(|i| i + index)
        {
            slice[index + 9 .. end].trim()
        }
        else { return "".to_string(); }
    }
    else { return "".to_string(); };

    // find and remember implementors
    while pos < slice.len()
    {
        // TODO: merge if let chaining becomes stable
        if let Some(index) = slice[pos..]
            .find("// impl Visitor<").map(|i| i + pos)
        {
            if let Some(post_type) = slice[index..]
                .find("> for").map(|i| i + index)
            {
                if let Some(post_struct) = slice[post_type..]
                    .find(':').map(|i| i + post_type)
                {
                    if let Some(end) = slice[post_struct..]
                        .find(';').map(|i| i + post_struct)
                    {
                        visitors.push((&slice[index + 16 .. post_type].trim(),
                            &slice[post_type + 5 .. post_struct].trim(),
                            &slice[post_struct + 1 .. end].trim()));
                        pos = index + 1;
                    }
                    else { break }
                }
                else { break }
            }
            else { break }
        }
        else { break }
    }

    // find and remember attributes
    pos = 0;
    while pos < slice.len()
    {
        // TODO: merge if let chaining becomes stable
        if let Some(index) = slice[pos..]
            .find("// attr").map(|i| i + pos)
        {
            if let Some(post_name) = slice[index..]
                .find(":").map(|i| i + index)
            {
                if let Some(end) = slice[post_name..]
                    .find(";").map(|i| i + post_name)
                {
                    attrs.push((&slice[index + 7 .. post_name].trim(),
                        &slice[post_name + 1 .. end].trim()));
                    pos = index + 1
                }
                else { break }
            }
            else { break }
        }
        else { break }
    }

    // find and remember cast types
    pos = 0;
    while pos < slice.len()
    {
        // TODO: merge if let chaining becomes stable
        if let Some(index) = slice[pos..]
            .find("// cast:").map(|i| i + pos)
        {
            if let Some(end) = slice[index..]
                .find(";").map(|i| i + index)
            {
                let cast = &slice[index + 8 .. end].trim();
                if cast.is_char_boundary(1) && &cast[..1] == "&"
                { ref_casts.push(cast[1..].trim()); }
                else { casts.push(cast); }
                pos = index + 1
            }
            else { break }
        }
        else { break }
    }

    // find and remember types and their fields
    pos = 0;
    while pos < slice.len()
    {
        // TODO: merge if let chaining becomes stable
        if let Some(index) = slice[pos..]
            .find("// type").map(|i| i + pos)
        {
            if let Some(post_type) = slice[index..]
                .find(":").map(|i| i + index)
            {
                if let Some(end) = slice[post_type..]
                    .find(";").map(|i| i + post_type)
                {
                    type_fields.push((&slice[index + 7 .. post_type].trim(),
                        &slice[post_type + 1 .. end].trim()));
                    pos = index + 1
                }
                else { break }
            }
            else { break }
        }
        else { break }
    }

    text.push_str(GEN_MARKER);

    let mut main_methods = String::new();
    let main_attrs = &attrs.iter().map(|tuple| {
        let (name, kind) = tuple;
        MAIN_ATTR.to_string()
            .replace("NAME", name)
            .replace("TYPE", kind)
    }).collect::<Vec<String>>().join("");
    let attr_decl = &attrs.iter().map(|tuple| {
        let (name, kind) = tuple;
        ATTR_DECL.to_string()
            .replace("NAME", name)
            .replace("TYPE", kind)
    }).collect::<Vec<String>>().join("");
    let attr_impl = attrs.iter().map(|tuple| {
        let (name, kind) = tuple;
        ATTR_DECL.to_string()
            .replace(";", " { self.NAME }")
            .replace("NAME", name)
            .replace("TYPE", kind)
    }).collect::<Vec<String>>().join("").to_string();
    let cast_decl = &casts.iter().map(|kind| {
        let kindl = &kind.to_lowercase();
        CAST_DECL.to_string()
            .replace("TYPEL", kindl)
            .replace("TYPE", kind)
    }).collect::<Vec<String>>().join("");
    let ref_cast_decl = &ref_casts.iter().map(|kind| {
        let kindl = &kind.to_lowercase();
        REF_CAST_DECL.to_string()
            .replace("TYPEL", kindl)
            .replace("TYPE", kind)
    }).collect::<Vec<String>>().join("").to_string();
    if attrs.len() != 0
    {
        main_methods.push_str(attr_decl);
        main_methods.push_str(cast_decl);
        main_methods.push_str(ref_cast_decl);
        main_methods.push_str("\n");
    }
    if visitors.len() != 0
    {
        main_methods.push_str(&visitors.iter().map(|tuple| {
            let (returns, kind, verb) = tuple;
            MAIN_VISIT.to_string()
                .replace("VERB", verb)
                .replace("TYPE", kind)
                .replace("RETURNS", returns)
        }).collect::<Vec<String>>().join(""));
        main_methods.push_str("\n");
    }
    text.push_str(&MAIN_TRAIT.to_string()
        .replace("MAIN", main_type)
        .replace("METHODS", &main_methods.trim()));

    let mut visit_methods = String::new();
    if visitors.len() != 0
    {
        text.push_str(&VISIT_TRAIT.to_string()
            .replace("METHODS", &type_fields.iter().map(|tuple| {
                let (kind, _) = tuple;
                let kindl = &kind.to_lowercase();
                VISIT_METHOD.to_string()
                    .replace("TYPEL", kindl)
                    .replace("TYPE", kind)
            }).collect::<Vec<String>>().join("")));
        visit_methods.push_str(&visitors.iter().map(|tuple| {
            let (returns, kind, verb) = tuple;
            MAIN_VISIT.to_string()
                .replace("VERB", verb)
                .replace("TYPE", kind)
                .replace("RETURNS", returns)
                .replace(";", &MAIN_VISIT_BODY.to_string()
                    .replace("VERB", verb)
                    .replace("VISIT", kind))
        }).collect::<Vec<String>>().join(""));
        visit_methods.push('\n');
    }
    type_fields.iter().for_each(|tuple| {
        let (kind, args) = tuple;
        let kindl = &kind.to_lowercase();
        let mut body = String::new();
        body.push_str(&attr_impl);
        body.push_str(&casts.iter().map(|cast_kind| {
            let cast_kindl = &cast_kind.to_lowercase();
            CAST_DECL.to_string()
                .replace("TYPEL", cast_kindl)
                .replace("TYPE", cast_kind)
                .replace(";", if kind != cast_kind { " { None }" }
                    else { " { Some(*self) }" })
        }).collect::<Vec<String>>().join(""));
        body.push_str(&ref_casts.iter().map(|cast_kind| {
            let cast_kindl = &cast_kind.to_lowercase();
            REF_CAST_DECL.to_string()
                .replace("TYPEL", cast_kindl)
                .replace("TYPE", cast_kind)
                .replace(";", if kind != cast_kind { " { None }" }
                    else { " { Some(self) }" })
        }).collect::<Vec<String>>().join(""));
        if body.len() != 0 { body.push('\n'); }
        body.push_str(&visit_methods);
        let mut argsn = main_attrs.to_string()
            .replace(";", ",");
        argsn.push_str("\tpub ");
        argsn.push_str(&args.to_string()
            .replace(", ", ",\n\tpub "));
        text.push_str(&TYPE_CODE.to_string()
            .replace("TYPE", kind)
            .replace("ARGSN", &argsn)
            .replace("ARGS", &args));
        text.push_str(&VISIT_CODE.to_string()
            .replace("MAIN", main_type)
            .replace("METHODS", body.trim())
            .replace("TYPEL", kindl)
            .replace("TYPE", kind));
    });

    text.replace("\t", &" ".repeat(TAB_SIZE))
}
