use std::{
    env,
    fs,
    str
};

fn main()
{
    env::args().skip(1).for_each(|arg| {
        match fs::read(&arg)
        {
            Ok(data) => match str::from_utf8(&data)
            {
                Ok(text) => match fs::write(&arg, generate_ast(text))
                {
                    Ok(()) => {},
                    Err(err) => println!("Error writing {arg}: {err}")
                },
                Err(err) => println!("Error reading {arg}: {err}")
            },
            Err(err) => println!("Error reading {arg}: {err}")
        }
    });
}

fn generate_ast(mut slice: &str) -> String
{
    const GEN_MARKER: &str = "\n// autogenerated code\n";
    const TYPE_CODE: &str = "\nstruct TYPE\n{\n\tARGSN\n}\n";
    const VISIT_CODE: &str = "\nimpl TYPE\n{VISIT}\n";
    const VISIT_METHOD: &str = "\n\tpub fn visit(&self, visitor: VISITOR)\n\t{\n\t\tvisitor.visit_TYPEL(&self);\n\t}\n";

    if let Some(index) = slice.find(GEN_MARKER)
    { slice = &slice[..index]; }
    let mut text: String = slice.to_string();
    let mut pos = 0;
    let mut visitors: Vec<&str> = Vec::new();
    while pos < slice.len()
    {
        // TODO: merge if let chaining becomes stable
        if let Some(index) = slice[pos..]
            .find("impl Visitor for")
            .map(|i| i + pos)
        {
            if let Some(end) = slice[index..].find('{').map(|i| i + index)
            {
                visitors.push(&slice[index + 16 .. end].trim());
                pos = index + 1;
            }
            else { break }
        }
        else { break }
    }
    text.push_str(GEN_MARKER);

    let expr_types = Vec::from([
        ("Binary", "left: Box<dyn Expr>, oper: TokenType, right: Box<dyn Expr>"),
        ("Grouping", "expr: Box<dyn Expr>"),
        ("Literal", "value: LoxValue"),
        ("Unary", "oper: TokenType, expr: Box<dyn Expr>")
    ]);
    let visitorImpl = visitors.iter().map(|visitor| {
        VISIT_METHOD.to_string()
        .replace("VISITOR", visitor)
    }).collect::<Vec<String>>().join("");
    expr_types.iter().for_each(|tuple| {
        let (kind, args) = tuple;
        let kindl = &kind.to_lowercase();
        text.push_str(&TYPE_CODE.to_string()
            .replace("TYPE", kind)
            .replace("ARGSN", &args.to_string()
                .replace(", ", ",\n\t"))
            .replace("ARGS", args));
        if visitors.len() != 0
        {
            text.push_str(&VISIT_CODE.to_string()
                .replace("VISIT", &visitorImpl) 
                .replace("TYPEL", kindl)
                .replace("TYPE", kind));
        }
    });

    text
}
